//! Problems in LeetCode
//! 

mod lru;

use super::list_node::ListNode;
use super::tree_node::TreeNode;
use std::{
    rc::Rc,
    cell::RefCell
};
pub struct Problems;

impl Problems {
    pub fn reverse_list(_head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        todo!()
    }
    pub fn middle_node(_head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        todo!()
    }
    pub fn merge_two_lists(_l1: Option<Box<ListNode>>, _l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        todo!()   
    }
    pub fn remove_elements(_head: Option<Box<ListNode>>, _val: i32) -> Option<Box<ListNode>> {
        todo!()
    }
    pub fn delete_duplicates(_head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        todo!()   
    }
    pub fn swap_pairs(_head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        todo!()   
    }
    pub fn rotate_right(_head: Option<Box<ListNode>>, _k: i32) -> Option<Box<ListNode>> {
        todo!()
    }
    pub fn is_same_tree(_p: Option<Rc<RefCell<TreeNode>>>, _q: Option<Rc<RefCell<TreeNode>>>) -> bool {
        todo!()   
    }
    pub fn invert_tree(_root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        todo!()
    }
    pub fn is_symmetric(_root: Option<Rc<RefCell<TreeNode>>>) -> bool {
        todo!()
    }
    pub fn merge_trees(root1: Option<Rc<RefCell<TreeNode>>>, root2: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        todo!()
    }
    pub fn search_bst(root: Option<Rc<RefCell<TreeNode>>>, val: i32) -> Option<Rc<RefCell<TreeNode>>> {
        todo!()   
    }
    pub fn prune_tree(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        todo!()   
    }
    pub fn convert_bst(root: Option<Rc<RefCell<TreeNode>>>) -> Option<Rc<RefCell<TreeNode>>> {
        todo!()
    }
    pub fn add_one_row(root: Option<Rc<RefCell<TreeNode>>>, v: i32, d: i32) -> Option<Rc<RefCell<TreeNode>>> {
        todo!()
    }
    pub fn delete_duplicates_2(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        todo!()
    }
    pub fn reverse_between(head: Option<Box<ListNode>>, left: i32, right: i32) -> Option<Box<ListNode>> {
        todo!()
    }
    pub fn construct_maximum_binary_tree(nums: Vec<i32>) -> Option<Rc<RefCell<TreeNode>>> {
        todo!()   
    }
    pub fn int_to_roman(num: i32) -> String {
        todo!()
    }
    pub fn LRU(&self, operators: Vec<Vec<i32>>, k: i32) -> Vec<i32> {
        todo!()
    }
    pub fn three_sum(nums: Vec<i32>) -> Vec<Vec<i32>> {
        todo!()
    }
    pub fn longest_palindrome(s: String) -> String {
        todo!()
    }
    pub fn max_area(height: Vec<i32>) -> i32 {
        todo!()
    }
    pub fn convert(s: String, num_rows: i32) -> String {
        todo!()
    }
    pub fn letter_combinations(digits: String) -> Vec<String> {
        todo!()
    }
    pub fn add_two_numbers(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> {
        todo!()
    }
    pub fn length_of_longest_substring(s: String) -> i32 {
        todo!()
    }
    pub fn find_median_sorted_arrays(nums1: Vec<i32>, nums2: Vec<i32>) -> f64 {
        todo!()
    }
    pub fn remove_nth_from_end(head: Option<Box<ListNode>>, n: i32) -> Option<Box<ListNode>> {
        todo!()
    }
    pub fn trap(height: Vec<i32>) -> i32 {
        todo!()
    }
    pub fn search(nums: Vec<i32>, target: i32) -> i32 {
        todo!()
    }
    pub fn get_winner(arr: Vec<i32>, k: i32) -> i32 {
        todo!()
    }
    pub fn three_sum_closest(nums: Vec<i32>, target: i32) -> i32 {
        todo!()
    }
    pub fn generate_parenthesis(n: i32) -> Vec<String> {
        todo!()
    }
    pub fn inorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {
        todo!()
    }
    pub fn level_order(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<Vec<i32>> {
        todo!()
    }
    pub fn postorder_traversal(root: Option<Rc<RefCell<TreeNode>>>) -> Vec<i32> {
        todo!()
    }
    pub fn my_pow(x: f64, n: i32) -> f64 {
        todo!()
    }
    pub fn max_sub_array(nums: Vec<i32>) -> i32 {
        todo!()
    }
    pub fn can_jump(nums: Vec<i32>) -> bool {
        todo!()
    }
    pub fn construct_arr(a: Vec<i32>) -> Vec<i32> {
        todo!()
    }
    pub fn min_path_sum(grid: Vec<Vec<i32>>) -> i32 {
        todo!()
    }
    pub fn merge(intervals: Vec<Vec<i32>>) -> Vec<Vec<i32>> {
        todo!()
    }
    pub fn unique_paths(m: i32, n: i32) -> i32 {
        todo!()
    }
    pub fn unique_paths_with_obstacles(obstacle_grid: Vec<Vec<i32>>) -> i32 {
        todo!()
    }
}

